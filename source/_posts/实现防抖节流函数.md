---
title: 实现防抖 | 节流函数
comment: true
sidebar: true
link_refer:
  - url: null
    title: null
sticky: 0
date: 2022-11-27 11:52:41
tags: 手写系列
categories: js
---

<!-- #### {{ title }} {{ date }} -->

#### debounce 函数通常称为防抖动函数: 延迟 wait 毫秒后调用 fn 方法;之前的定时器会被清清除 生成一个虚拟的计时器

##### 原理: 闭包内维护了一个定时器 清除和新生成

<!--more-->

- ##### 简版防抖函数

```js
  function debounce (fn, wait = 200) {
    let timer = null;
    return function(...arg) {
      timer && clearTimeout(timer) && timer = null
      timer = setTimeout(function(){
        fn.apply(this, arg)
      }, wait)
    }
  }
```

---

- ##### 完整版防抖函数(立即执行)
  **如果需要返回原值可以使用 promise | 和回调 calllback 解决**

```js
function debounce(fn, wait = 200, immediate) {
  let timer = null;
  let debounced = function (...arg) {
    timer && clearTimeout(timer);
    if (immediate) {
      const imd = !timer;
      timer = setTimeout(function () {
        timer = null;
      }, wait);
      if (imd) fn.apply(this, arg);
    } else {
      timer = setTimeout(function () {
        fn.apply(this, arg);
      }, wait);
    }
  };
  debounced.cancel = function () {
    timer && clearTimeout(timer);
    timer = null;
  };
  return debounced;
}
```

#### throttle 函数通常称为节流函数: 在 wait 秒内最多执行 fn 一次的函数

```js
function throttle(fn, wait = 200, immediate) {
  let timer = null;
  let imd = true;
  let throttled = function (...arg) {
    if (imd) {
      fn.apply(this, arg);
      imd = false;
      return;
    }
    if (timer) return;

    timer = setTimeout(function () {
      timer && clearTimeout(timer);
      timer = null;
      fn.apply(this, arg);
    }, wait);
  };
  return throttled;
}
```

## **throttle 相对于 debounce 的最大区别就是它不会取消上一次函数的执行。**
